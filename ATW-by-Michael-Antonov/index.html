<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="google-site-verification" content="rMF1JqbmMsHu2M1zSLQ482HWMOd8u-4z-zWViLWMXHg" />
<meta name="msvalidate.01" content="41CDEF49B6C0AE7EBCA90FD97E410ADE" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"treeknows.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="翻译文章，原文链接：Asynchronous Timewarp Examined Written by: Michael Antonov • 2015年3月3日  文章格式安排如下：  英文原文  中文译文 （自言自语）">
<meta property="og:type" content="article">
<meta property="og:title" content="ATW概述-by Michael Antonov">
<meta property="og:url" content="https://treeknows.github.io/ATW-by-Michael-Antonov/index.html">
<meta property="og:site_name" content="Hi tree">
<meta property="og:description" content="翻译文章，原文链接：Asynchronous Timewarp Examined Written by: Michael Antonov • 2015年3月3日  文章格式安排如下：  英文原文  中文译文 （自言自语）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/double-image-judder.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/double-image-judder.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/multiple-image-judder-with-near-field-objects.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/multiple-image-judder-with-near-field-objects.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/moving-object-affected-by-judder.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/moving-object-affected-by-judder.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/specular-and-reflection.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/specular-and-reflection2.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/specular-and-reflection.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/specular-and-reflection2.jpg">
<meta property="article:published_time" content="2024-01-04T05:57:50.000Z">
<meta property="article:modified_time" content="2024-01-04T08:31:26.289Z">
<meta property="article:author" content="treeknows">
<meta property="article:tag" content="XR">
<meta property="article:tag" content="Rendering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/double-image-judder.jpg">

<link rel="canonical" href="https://treeknows.github.io/ATW-by-Michael-Antonov/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>ATW概述-by Michael Antonov | Hi tree</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-8W35JPL36V"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-8W35JPL36V');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hi tree</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">行有不得，反求诸己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://treeknows.github.io/ATW-by-Michael-Antonov/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="treeknows">
      <meta itemprop="description" content="Let me grow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hi tree">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ATW概述-by Michael Antonov
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-01-04 13:57:50 / 修改时间：16:31:26" itemprop="dateCreated datePublished" datetime="2024-01-04T13:57:50+08:00">2024-01-04</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<p><strong>翻译文章，原文链接：<a target="_blank" rel="noopener" href="https://developer.oculus.com/blog/asynchronous-timewarp-examined/">Asynchronous Timewarp Examined</a></strong></p>
<p><strong>Written by: Michael Antonov • 2015年3月3日</strong></p>
<hr>
<p>文章格式安排如下：</p>
<blockquote>
<p>英文原文</p>
</blockquote>
<p>中文译文</p>
<p>（自言自语）</p>
<hr>
<span id="more"></span>
<blockquote>
<p><em><strong>TL;DR:</strong> Asynchronous timewarp (ATW) is a technique that generates intermediate frames in situations when the game can’t maintain frame rate, helping to reduce judder. However, ATW is not a silver bullet and has limitations that developers should be aware of.</em></p>
</blockquote>
<p><em>Too long, don’t read. 异步时间扭曲(ATW)是一种在游戏无法保持帧率时生成中间帧的技术，帮助减少抖动。然而，ATW并不是万能的，它也有一些局限性，开发人员应当知晓。</em></p>
<blockquote>
<p><strong>Intro</strong></p>
<p>Over the past year there’s been a lot of excitement around asynchronous timewarp (ATW). Many hoped that ATW would allow engines to run and render at a lower frame rate, using ATW to artificially fill in dropped frames without a significant drop in the VR quality.</p>
<p>On Gear VR Innovator Edition, ATW has been a key part of delivering a great experience. Unfortunately, it turns out there are intrinsic limitations and technical challenges that prevent ATW from being a universal solution for judder on PC VR systems with positional tracking like the Rift. Under some conditions, the perceptual effects of timewarp judder in VR can be almost as bad as judder due to skipped frames.</p>
<p>In this blog, we analyze these limitations and situations that cause particular difficulties. As you’ll see, while ATW may be helpful at times, there is no substitute for hitting the full frame rate when it comes to delivering great VR.</p>
</blockquote>
<p><strong>介绍</strong></p>
<p>过去一年里人们对ATW表现出了很大的兴奋。许多人希望ATW能让引擎以更低的帧率运行和渲染，利用ATW认为的补充丢帧，而不会明显降低VR的质量。</p>
<p>在Gear VR创新版上，ATW成为了提供出色体验的关键部分。遗憾的是，由于存在一些内在限制和技术难题，ATW无法成为解决像Rift等带有位置追踪功能的PC VR系统上抖动问题的通用方案。在一些情况下，在虚拟现实中应用ATW后的效果和由跳帧引起的抖动效果一样糟糕。</p>
<p>在本博客中，我们将分析这些限制以及造成特殊困难的情况。正如你将看到的，ATW有时可能是有帮助的，但要提供出色的VR效果，全帧率是无可替代的。</p>
<p>（应该是指，帧率拉满的效果是ATW望尘莫及的）</p>
<blockquote>
<p><strong>Timewarp, Asynchronous Timewarp, and Judder</strong></p>
<p>Timewarp is a technique that warps the rendered image before sending it to the display in order to correct for head motion that occurred after the scene was rendered and thereby reduce the perceived latency. The basic version of this is orientation-only timewarp, in which only the rotational change in the head pose is corrected for; this has the considerable advantage of being a 2D warp, so it does not cost much performance when combined with the distortion pass. For reasonably complex scenes, this can be done with much less computation than rendering a whole new frame.</p>
</blockquote>
<p><strong>时间扭曲、异步时间扭曲和抖动</strong></p>
<p>TW是一种技术，在送显之前将渲染过的图像扭曲，从而纠正场景渲染后（渲染后到送显前这一段）发生的头部运动，减少感知延迟。最基础的时间扭曲是基于朝向（头部）的，这种方式只对头部姿势的旋转变化进行了校正。这种方法的显著优点是这是二维的扭曲，在与畸变矫正结合时不会太影响性能。对于相当复杂的场景，这比渲染一帧全新画面所需的计算量要少得多。</p>
<blockquote>
<p>Asynchronous timewarp refers to doing this on another thread in parallel (i.e. asynchronously) with rendering. Before every vsync, the ATW thread generates a new timewarped frame from the latest frame completed by the rendering thread.</p>
</blockquote>
<p>ATW是指在一条和渲染线程并行的（扭曲）线程上工作。在每次VSync之前，ATW线程基于渲染线程完成的最新帧生成一帧扭曲过的帧。</p>
<blockquote>
<p>Judder and its consequences are covered in detail by Michael Abrash in his <a target="_blank" rel="noopener" href="http://blogs.valvesoftware.com/abrash/">2013 blog posts here</a>. Reviewing Michael’s notes on judder would be helpful to get the most out of this post.</p>
</blockquote>
<p>Michael Abrash（作者本人）在其 2013 年的博文（原文中贴的链接已失效）中详细介绍了抖动及其后果。阅读迈克尔关于抖动的笔记将有助于您更好地理解本篇文章。</p>
<blockquote>
<p>In order to produce a perceptually correct representation of the virtual world, the images on the displays must be updated with every vsync refresh. However, if rendering takes too long, a frame will be missed, resulting in judder. This is because when no new frame has been rendered, the video adapter scans out the same image a second time. Here is what an object location looks like if the same rendered frame is displayed two frames in a row before updating:</p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/double-image-judder.jpg" alt=""></p>
<p><em>Here, the eye is rotating to the left. When the same image is displayed again, its light falls on a different part of the retina, resulting in double image judder.</em></p>
</blockquote>
<p>为了在虚拟世界呈现正确的感知，屏幕图像必须在每次VSync时刷新。然而，如果渲染耗费太长时间，就会错过一帧，这就导致了抖动。这是因为当没有渲染新的帧时，视频适配器对同一张图像进行了二次扫描。在更新前连续显示同一渲染帧时，对象位置的情况如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/double-image-judder.jpg" alt=""></p>
<p><em>在这里，眼睛向左旋转。当再次显示同一图像时，光线落在视网膜的不同部分，导致重影抖动。</em></p>
<blockquote>
<p>Of course, doubling is not the only possible effect. If we displayed the same frame three times in a row, you would get a triple image on your retina and so on.</p>
</blockquote>
<p>当然，重影不是唯一可能的效果。如果我们连续显示同一帧三次，你会看到三重图像，以此类推。</p>
<blockquote>
<p>Orientation-only ATW can be used to help address judder: if the rendered game frame is not submitted before vsync, timewarp can interrupt and generate the image instead, by warping the last frame to reflect the head motion since the last frame was rendered. Although this new image will not be exactly correct, it will have been adjusted for head rotation, so displaying it will reduce judder as compared to displaying the original frame again, which is what would have happened without ATW.</p>
</blockquote>
<p>基于方向的ATW可以帮助解决抖动问题：如果渲染的游戏帧没有在VSync到来前提交，TW会中断（渲染线程）并生成图像，通过扭曲最后一帧来代表最后一帧以来的头部运动。虽然新的图像并不完全正确，但它已经根据头部旋转进行了调整，因此显示这一帧（扭曲生成的帧）相比在没有ATW的情况下显示同一帧（上一帧），可以减少抖动。</p>
<blockquote>
<p>In certain situations, simple rotation-warping can work well. It has been implemented on Gear VR Innovator Edition, where it fills in the frames whenever games can’t meet the frame rate. This smooths many glitches to the point where they’re mostly not noticeable. Because Gear VR lacks position tracking and the content generally avoids near-field objects, many of the artifacts discussed below are lessened or avoided.</p>
</blockquote>
<p>在某些确定的场景下，简单的旋转-扭曲效果会很好。在Gear VR创新版上已经实现：当游戏帧无法满足要求时，它就会填充帧数。这使许多故障变得平滑，在大多数情况下都不易察觉。由于 Gear VR 缺乏位置跟踪功能，而且内容一般都会避开近场物体，因此下面讨论的许多假象都会减少或避免。</p>
<p>（在计算机图形学中，我们以绘制出以假乱真的图景为目标，但是经常会绘制出来锯齿状边缘，或者一些颜色错误，我们会称之为<strong>artifact</strong>，意思是这里绘制得不自然）</p>
<blockquote>
<p>There are several reasons why ATW on the PC is significantly more challenging than on Gear VR, starting with the Rift’s support for positional tracking.</p>
</blockquote>
<p>PC 上的 ATW 比 Gear VR 上的更具挑战性，原因有几个，首先是 Rift 支持定位追踪。</p>
<blockquote>
<p><strong>Positional Judder</strong></p>
<p>Positional judder is one of the most obvious artifacts with orientation-only timewarp. When you move your head, only the additional rotational component is reflected in the ATW-generated images, while any translational head movement since the frame was rendered is ignored. This means that as you move your head from side to side, or even just rotate your head which translates your eyes, you will see multiple-image judder on objects that are close to you. The effect is very noticeable in spaces with near field objects, such as the submarine screenshot below.</p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/multiple-image-judder-with-near-field-objects.jpg" alt=""></p>
</blockquote>
<p><strong>位置抖动</strong></p>
<p>位置抖动是基于方向的时间扭曲带来的最明显的瑕疵之一。当移动头部时，只有额外的旋转部分会反映在ATW生成的图像中，而自帧被渲染以来的所有头部平移都会被忽略。这就意味着当左右移动头部，甚至只是旋转头部使眼睛平移时，将在靠近的物体上观察到多重图像抖动。这种效果在有近场物体时非常明显，例如下面的潜艇截图：</p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/multiple-image-judder-with-near-field-objects.jpg" alt=""></p>
<blockquote>
<p>So, how bad is this effect?</p>
<p>The magnitude of positional judder depends on the environment the player is in and the types of movements they make. If you keep your head relatively still and only look around at the scenery, the positional error will be small and the judder will not be very noticeable.</p>
<p><strong>Note:</strong> This is normally the case for Gear VR Innovator Edition, which doesn’t include positional tracking. Nevertheless, the head model generates virtual translations, so when a game is running at half-rate on Gear VR, you can still observe positional judder on near-field objects.</p>
</blockquote>
<p>那么，这种影响有多严重？</p>
<p>位置抖动的程度取决于玩家所处的环境和所做的动作类型。如果你的头部保持相对静止，只是环顾四周的景物，那么位置误差会很小，抖动也不会很明显。（说白了就是不做头部平移？）</p>
<p><strong>注意</strong>：Gear VR 创新版通常就是这种情况，因为它不包含位置跟踪功能。不过，头部模型会产生虚拟平移，因此当游戏在 Gear VR 上以半速率运行时，您仍然可以观察到近场物体的位置抖动。</p>
<blockquote>
<p>If you’re looking at objects far away, the displacement change due to your head movement is unlikely to be significant enough to be noticeable. In these cases, ATW allows you to look around a scene with mid-to-far-field geometry without any noticeable judder.</p>
<p>On the other hand, if you’re in a environment with near-field detail, and you translate your head, the positional judder will be nearly as bad as running without ATW. This will also be true when you look down at a textured ground plane, which is not far enough away to avoid artifacts. The resulting perceptual effect is that of a glitchy, unstable world, which can be disorienting and uncomfortable.</p>
</blockquote>
<p>如果你正在看远处的物体，头部移动造成的位移变化不太可能大到足以引起注意。在这种情况下，ATW使你环视带有中远景几何图形的场景而不引起明显的抖动。</p>
<p>另一方面，如果处于带有近景细节的环境，并且移动了头部，那么位置抖动将与不使用ATW时一样严重。低头看有纹理的地面也是如此。因为距离不够远，无法避免伪影。由此产生的感知效果是一个闪烁、不稳定的时间，会让人迷失方向，感到不舒服。</p>
<blockquote>
<p><strong>Positional Timewarp</strong></p>
<p>One possible way to address positional judder is to implement full positional warping, which applies both translation and orientation fixups to the original rendered frame. Positional warping needs to consider the depth of the original rendered frame, displacing parts of the image by different amounts. However, such displacement generates dis-occlusion artifacts at object edges, where areas of space are uncovered that don’t have data in the original frame.</p>
<p>Additionally, positional warping is more expensive, can’t easily handle translucency, has trouble with certain anti-aliasing approaches, and doesn’t address the other ATW artifacts discussed below.\</p>
</blockquote>
<p><strong>位置扭曲</strong></p>
<p>解决位置抖动的一种可能的方法为实现全位置扭曲，对原始渲染帧进行方向（朝向）和平移修正。位置扭曲需要考虑原始渲染帧的深度信息，对图像的不同部分进行不同程度的位移。然而，这样产生的中间帧会使物体边缘不闭合，由于没有原始帧中的数据，会导致中间帧某些区域不能被覆盖。</p>
<p>此外，位置扭曲成本更高，无法轻松处理半透明效果，在使用某些抗锯齿方法时会出现问题，而且无法解决下文中讨论的其他ATW的情形。</p>
<blockquote>
<p><strong>Moving and Animated Objects</strong></p>
<p>Animated or moving objects cause another artifact with ATW: because a new image is generated just by warping the original image without knowledge of the movement of objects, for all ATW-generated frames they are effectively frozen in time. This artifact manifests as multiple images of these moving objects — i.e. judder.</p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/moving-object-affected-by-judder.jpg" alt=""></p>
<center>Image of scene with a moving object affected by judder.</center>
</blockquote>
<p><strong>移动和动画物体</strong></p>
<p>动画或移动中的物体导致了另一个ATW中的瑕疵：由于新图像是在不知道物体移动的情况下通过扭曲原始图像生成的，因此在所有ATW生成的帧中，这些物体实际上都被冻结在时间中。这种伪像表现为这些移动物体的多幅图像，即抖动。</p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/moving-object-affected-by-judder.jpg" alt=""></p>
<center>Image of scene with a moving object affected by judder.</center>
<blockquote>
<p>The impact of this artifact depends on the number, projected area, and speed of animated objects in the game scene: if the number or size of moving objects is small or they are not moving fast, the multiple images may not be particularly noticeable. However, when moving objects or animation covers a large portion of the screen it can be disturbing.</p>
<p>Additionally, the frame rate ratio between the game rendering and device refresh rate affects the perceived quality of the motion judder. In our experience, ATW should run at a fixed fraction of the game frame rate. For example, at 90Hz refresh rate, we should either hit 90Hz or fall down to the half-rate of 45Hz with ATW. This will result in image doubling, but the relative positions of the double images on the retina will be stable. Rendering at an intermediate rate, such as 65Hz, will result in a constantly changing number and position of the images on the retina, which is a worse artifact.</p>
</blockquote>
<p>这种伪影的影响取决于游戏场景中动画的数量、投影面积和速度：如果正在移动的物体的数量较少或形状较小或移动速度不快，那么重影可能不会太明显。但是，当移动的物体或动画占据了屏幕的大部分区域，就会造成干扰。</p>
<p>此外，游戏渲染帧率和屏幕刷新率之间的比值也会影响抖动的感知质量。根据经验，ATW应该以游戏帧率的固定比例运行。例如，在90赫兹的刷新率下，ATW要么达到90Hz，要么降到45Hz运行。这将导致图像加倍，但双图像在视网膜上的相对位置将保持稳定。以65Hz这样的中间帧率渲染会导致视网膜上图像的数量和位置不断改变，从而产生更糟糕的伪影。</p>
<blockquote>
<p><strong>Specular and Reflection</strong></p>
<p>Calculations for reflections and specular lighting consider the direction of the eye vector, or rendering camera vector, to produce an image that is custom rendered for each eye.</p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/specular-and-reflection.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/specular-and-reflection2.jpg" alt=""></p>
</blockquote>
<p><strong>镜面反射</strong></p>
<p>计算镜面反射需考虑眼睛的方向， 或摄像机（Unity里的camera？）的方向， 由此为每只眼睛生成一张定制的渲染画面。</p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/specular-and-reflection.jpg" alt=""></p>
<p><img src="https://raw.githubusercontent.com/treeknows/blog_pic/master/imgs/specular-and-reflection2.jpg" alt=""></p>
<blockquote>
<p><em>Diagrams courtesy of Wikipedia and <a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial19/tutorial19.html">http://ogldev.atspace.co.uk/www/tutorial19/tutorial19.html</a> respectively.</em></p>
<p>Since this eye vector changes with head movement, specular and reflection rendering is no longer correct after timewarp. This may result in reflections and specular highlights juddering.</p>
<p>While specular highlights and reflections are two of the most common cases where shading relies on the eye vector, many other eye vector-dependent shading tricks will have similar issues. For example, parallax mapping and relief mapping (aka. parallax occlusion mapping) will show similar artifacts.</p>
</blockquote>
<p>图片来自维基百科和<a target="_blank" rel="noopener" href="http://ogldev.atspace.co.uk/www/tutorial19/tutorial19.html">网站</a></p>
<p>由于眼睛向量（？）会随着头部运动而改变，因此在TW后，镜面反射渲染将不再正确。这可能会导致镜面反射抖动。</p>
<p>虽然镜面高光和反射是依靠眼球矢量着色的两种最常见情况，许多其他依赖眼球向量的着色技巧也有类似的问题。例如，视差贴图和浮雕映射(又称为视差遮挡映射)也会有类似的现象。</p>
<blockquote>
<p><strong>Implementation</strong></p>
<p>Implementing ATW is challenging for two primary reasons:</p>
<ul>
<li>It requires GPU HW to support preemption at reasonable granularity</li>
<li>It requires OS and driver support to expose GPU preemption</li>
</ul>
<p>Let’s start with preemption granularity. At 90Hz, the interval between frames is roughly 11ms. This means that in order for ATW to have any chance of generating a frame, it must be able to preempt the main thread rendering commands and run in under 11ms.</p>
</blockquote>
<p><strong>ATW实现</strong></p>
<p>实现ATW有两个主要的技术挑战：</p>
<ul>
<li>需要GPU硬件以合理的粒度支持抢占</li>
<li>需要操作系统和驱动支持GPU抢占</li>
</ul>
<p>让我们从抢占粒度开始。在90Hz时，帧间隔大约是11ms。这意味着为了使ATW能有机会生成一帧，必须能够抢占主线程的渲染命令，并在11ms内运行。</p>
<blockquote>
<p>However, 11ms isn’t actually good enough — If ATW runs at randomly scheduled points within the frame, its latency (ie. the amount of time between execution and frame scan-out) will also be random. And, we need to make sure we don’t skip any game-rendered frames.</p>
<p>What we really want is for ATW to run consistently shortly before the video card flips to a new frame for scan-out, with just enough time to complete the generation of the new timewarped frame. Short of having custom vsync-triggered ATW interrupt routines, we can achieve this with high-priority preemption granularity and scheduling of around 2ms or less.</p>
</blockquote>
<p>然而，11ms实际上还不够好：如果ATW在一帧内随机的时间点开始运行，其延迟(执行和帧扫描之间的时间间隔)也将是随机的。而且，我们需要确保不会调过任何游戏渲染的帧。</p>
<p>我们真正想要的是ATW能够有刚刚足够的时间，在显卡切到新帧扫描输出前结束生成新的一帧。如果不使用定制的垂直同步触发的ATW中断例程，我们可以通过高优先级的抢占性调度，以及大约2毫秒或更短的时间来实现这一点。（它在说啥 😅）</p>
<blockquote>
<p>It turns out that 2ms preemption on general rendering is a tall order for modern video cards and driver implementations. Although many GPUs support limited forms of preemption, the implementation varies significantly:</p>
<ul>
<li>Some vendors and drivers allow preemption on either batch or draw call granularities. While helpful, this is not perfect (eg. in an extreme case, a single large draw call with a complex shader can easily take 10 ms).</li>
<li>Other vendors and drivers allow preemption of compute shaders, yet require vendor-specific extensions to support preemption of rendering with compute.</li>
</ul>
</blockquote>
<p>事实证明，对于现代显卡及驱动实现来讲，在一般的渲染中实现2ms抢占是一项艰巨的任务。虽然许多GPU都支持有限形式的抢占，但实现的方式确不尽相同。</p>
<ul>
<li>一些供应商和驱动允许在批处理或绘制调用粒度上进行抢占，这虽然有用，但是并不完美(例如，在极端情况下，复杂着色器的单个大型绘制调用可能轻松耗费10ms时间)。</li>
<li>其他供应商和驱动允许计算着色器的抢占，但是需要特定供应商的拓展来支持计算渲染的抢占。</li>
</ul>
<blockquote>
<p>If the preemption doesn’t occur quickly enough, ATW will not complete warping a new frame before vsync, and the last frame will be shown again, resulting in judder. This means that a correct implementation should be able to preempt and resume rendering arbitrarily, regardless of the pipeline state. In theory, even triangle-granularity preemption is not good enough because with complex shaders we don’t know how long rendering a triangle will take. We’re working with GPU manufacturers to implement better preemption, but it will be awhile before it’s ubiquitous.</p>
<p>Another part of the equation is rendering preemption support in the OS. Prior to Windows 8, Windows Display Driver Model (WDDM) supported limited preemption using “batch queue” granularity, where batches were built by the graphics driver. Unfortunately, graphics drivers tend to accumulate large batches for rendering efficiency, resulting in preemption that is too coarse to support ATW well.</p>
<p>With Windows 8, the situation improved as WDDM 1.2 added support for preemption at finer granularities; however, these preemption modes are currently not universally supported by graphics drivers. Rendering pipeline management is expected to improve significantly with Windows 10 and DirectX 12, which gives developers lower-level rendering control. This is good news, but we’re still left without a standard way to support rendering preemption until Windows 10 becomes mainstream. As a result, ATW will require vendor-specific driver extensions for the foreseeable future.</p>
</blockquote>
<p>如果抢占动作不够快，ATW将无法在VSync到来前扭曲生成新的帧，最后一帧将再次显示，导致抖动。这就意味着无论流水线的状态如何，正确的实现都应该能够随意的抢占和渲染。理论上，即便是三角粒度抢占（&lt;–没太明白是个啥）也不够好，因为对于复杂着色器，我们不知道渲染一个三角形需要多长时间。我们正与GPU制造商合作，实现更好的抢占功能，但要想普及还需要一段时间。</p>
<p>另一个因素是操作系统对渲染抢占的支持（equation 方程式）。在Win8之前，Windows显示驱动程序模型(WDDM)支持使用“批队列”粒度的有限抢占，其中批次由图形驱动程序构建。不幸的是，图形驱动往往会积累大量批次以提高渲染效率，这就导致抢占过于粗糙，无法很好地支持ATW。</p>
<p>在Win8中，情况有所改善，因为WDDM1.2支持了更细粒度的抢占；不过这些抢占模式目前还没有被图形驱动程序普遍支持。渲染管线管理预计将在Win10和DirectX 12上有显著改善，为开发人员提供更低级别的渲染控制。这是一个好消息，但是在Win10成为主流之前我们仍然缺少支持渲染抢占的标准方法。因此，在可见的将来，ATW仍将依赖特定供应商的驱动程序拓展。</p>
<blockquote>
<p><strong>ATW is helpful, but it’s not a silver bullet</strong></p>
<p>Once we have ubiquitous GPU rendering pipeline management and preemption, ATW may become another tool to help developers increase performance and reduce judder in VR. However, due to the issues and challenges we’ve outlined here, ATW is not a silver bullet — VR applications will want to sustain high framerates to deliver the best quality of experience. In the worst cases, ATW’s artifacts can cause users to have an uncomfortable experience. Or stated differently: in the worst cases, ATW can’t prevent an experience from being uncomfortable.</p>
<p>Given the complexities and artifacts involved, it’s clear that ATW, even with positional timewarp, won’t become a perfect universal solution. This means that both orientation-only and positional ATW are best thought of as pothole insurance, filling in when a frame is occasionally skipped. To deliver comfortable, compelling VR that truly generates presence, developers will still need to target a sustained frame rate of 90Hz+.</p>
</blockquote>
<p><strong>ATW有用，但不万能</strong></p>
<p>一旦我们拥有了无处不在的GPU渲染管线管理和抢占，ATW可能会成为帮助开发者提升VR性能，减少抖动的另一种工具。然而，基于上述的一些问题和挑战，ATW并不是万能的——VR应用期望维持高帧率以提供最好的体验效果。在最坏的情况下，ATW的伪影可能导致用户有不舒服的使用体验。换句话说，在最坏的情况下，ATW无法阻止体验变得不舒服。</p>
<p>鉴于所涉及的复杂性和人工痕迹，很明显对于ATW，甚至位置扭曲，不会成为一个完美的通用解决方案。这就意味着无论3dof的扭曲还是6dof的扭曲最好作为一个保险，在偶尔跳帧时填补空白。想要提供舒适、真实的VR体验，开发者仍需要将帧率保持在90Hz以上。</p>
<blockquote>
<p>Thankfully, Crysis-level graphics are by no means required to deliver incredible VR experiences. It’s perfectly reasonable to reduce the number of lights, the shadow detail, and the shader complexity if it means reaching that 90Hz sweet spot.</p>
<p>Dual-mode titles that try to support traditional monitors and VR will have the most performance difficulties, as the steep performance requirements for good VR quickly become a challenge to engine scalability. For developers in this situation, ATW may look very attractive despite the artifacts. However, as is typical with new mediums, ports are unlikely to be the best experiences; made-for-VR experiences that target 90Hz are likely to be substantially more successful in generating comfort, presence, and the true magic of VR.</p>
<p>— Michael Antonov, Chief Software Architect</p>
</blockquote>
<p>幸好，要提供惊艳的VR体验，不需要《孤岛危机》级别的图形。只要能够达到90Hz的最佳频率，减少灯光数量、阴影细节或着色器复杂度都是完全合理的。</p>
<p>试图同时支持传统显示器和VR的双模式游戏会遇到很大的性能问题，因为良好的VR对性能的很快就会成为对引擎可拓展性的挑战。在这种情况下，对开发者来说ATW会有十足的吸引力，尽管看起来会不自然。然而，与新媒体的典型情况一样，移植不可能带来最佳体验；以90Hz为目标的专门的VR体验可能会在产生舒适感、临场感和其他VR的神奇之处收获更多的成功。</p>
<p>—Michael Antonov, Chief Software Architect</p>
<hr>
<p>正文结束😀</p>

    </div>
	 <!-- 文章结束表示语-->
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------------------------------------The End <i class="fa fa-tree" color="#66FFCC"></i>-------------------------------------------</div>
    
</div>

      
    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\what-is-slam-algo\" rel="bookmark">认识SLAM算法</a></div>
    </li>
  </ul>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>treeknows
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://treeknows.github.io/ATW-by-Michael-Antonov/" title="ATW概述-by Michael Antonov">https://treeknows.github.io/ATW-by-Michael-Antonov/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/XR/" rel="tag"><i class="fa fa-tag"></i> XR</a>
              <a href="/tags/Rendering/" rel="tag"><i class="fa fa-tag"></i> Rendering</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/what-is-slam-algo/" rel="prev" title="认识SLAM算法">
      <i class="fa fa-chevron-left"></i> 认识SLAM算法
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="treeknows"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">treeknows</p>
  <div class="site-description" itemprop="description">Let me grow</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/treeknows/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;treeknows&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/treeknows@qq.com" title="E-Mail → treeknows@qq.com"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">treeknows</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">49k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">44 分钟</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '32px',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '22fb59ff85c3aef2677a',
      clientSecret: '246142feb132313b08ee3ff55678c88244b67b97',
      repo        : 'treeknows.github.io',
      owner       : 'treeknows',
      admin       : ['treeknows'],
      id          : 'e66e4bdaa4d865baf6b6f322352d6117',
        language: '',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
